Monkey patch — тимчасова заміна/зміна функцій, класів, змінних або середовища під час виконання (runtime).
Використовується у тестах для заміни залежностей (вхідних чи вихідних).

Фікстура monkeypatch у pytest:
працює в межах одного тесту;
після завершення тесту відновлює оригінальний стан.

Основні методи monkeypatch
- `setattr(target, name, value, raising=True)` → встановити атрибут.
- `delattr(target, name, raising=True)` → видалити атрибут.
- `setitem(dict, key, value)` → змінити значення у словнику.
- `delitem(dict, key, raising=True)` → видалити ключ зі словника.
- `setenv(name, value, prepend=None)` → задати змінну оточення.
- `delenv(name, raising=True)` → видалити змінну оточення.
- `syspath_prepend(path)` → додати шлях у `sys.path`.
- `chdir(path)` → змінити робочу директорію.

Параметри
- `raising=True` → якщо об’єкт/атрибут не існує, pytest підніме помилку.
- `prepend` (у `setenv`) → якщо задано, додає значення перед попереднім значенням змінної середовища.

Використання
Імітація поведінки функцій/залежностей.
Підміна системних викликів (наприклад, робота з файлами чи мережею).
Тестування коду без справжніх зовнішніх ресурсів.

- **`syspath_prepend(path)`**  
    У Python є список `sys.path`, де зберігаються всі папки, звідки інтерпретатор шукає модулі для імпорту.  
    Якщо ти додаси свій шлях **на початок цього списку**, Python спочатку дивитиметься туди.  
    Це зручно, коли ти хочеш підмінити якийсь системний або сторонній модуль своїм «стабом» (спрощеною версією) для тестів.
- **`chdir(path)`**  
    Змінює поточну робочу директорію.  
    Використовується, коли потрібно протестувати скрипти чи утиліти, які залежать від того, «де ти знаходишся» в файловій системі.  
    Наприклад, можна створити тимчасову папку з потрібними файлами і «перейти» туди під час тесту.
- **Разом з `unittest.mock`**  
    Можна комбінувати: monkeypatch підмінює середовище (файли, шляхи, змінні), а mock створює фейкові об’єкти/функції замість справжніх. Це дає ще більше контролю над тим, як код поводиться під час тесту.

Ідея в тому, що monkeypatch дає «ігровий майданчик» — ти тимчасово керуєш тим, звідки імпортуються модулі та яка поточна директорія, а після тесту все повертається як було.


**doctest_namespace**
The doctest module is part of the standard Python library and allows you to put little code
examples inside docstrings for a function and test them to make sure they work. You can have
pytest look for and run doctest tests within your Python code by using the *--doctest-modules* flag.
With the *doctest_namespace* builtin fixture, you can build autouse fixtures to add symbols to the namespace pytest uses while running doctest tests. This allows docstrings to be much more
readable. *doctest_namespace* is commonly used to add module imports into the namespace,
especially when Python convention is to shorten the module or package name. For instance,
numpy is often imported with import numpy as np.

**recwarn**
The recwarn builtin fixture is used to examine warnings generated by code under test. In Python,
you can add warnings that work a lot like assertions, but are used for things that don’t need to
stop execution. For example, suppose we want to stop supporting a function that we wish we had never put into a package but was released for others to use. We can put a warning in the code and leave it there for a release or two.


The ***pytest.warns()*** context manager provides an elegant way to demark what portion of the code you’re checking warnings. The recwarn fixture and the ***pytest.warns()*** context manager provide similar functionality, though, so the decision of which to use is purely a matter of taste.